import{_ as e,o as i,c as t,a,b as l,d as o,f as c}from"./app-f87a5745.js";const r={},n=l("p",null,[l("code",null,"webpack"),o(" 面试题")],-1),p=c('<ol><li><strong>webpack与grunt、gulp的不同？</strong></li></ol><div class="hint-container tip"><p class="hint-container-title">答案示例</p><p>三者都是前端构建工具，<code>grunt</code>和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。<br> grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。<br> webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。<br> 所以总结一下：</p><ul><li>从构建思路来说，gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系 webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工</li><li>对于知识背景来说，gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路</li></ul></div><ol start="2"><li><strong>与webpack类似的工具还有哪些？</strong></li></ol><div class="hint-container tip"><p class="hint-container-title">答案示例</p><p>同样是基于入口的打包工具还有以下几个主流的：<code>webpack</code>、<code>rollup</code>、<code>parcel</code><br> 从应用场景上来看：</p><ul><li>webpack适用于大型复杂的前端站点构建</li><li>rollup适用于基础库的打包，如vue、react</li><li>parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果<br> 由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel</li></ul></div><ol start="3"><li><strong>有哪些常见的Loader？</strong></li></ol><div class="hint-container tip"><p class="hint-container-title">答案示例</p><ul><li>file-loader：将一个文件中的 import/require() 解析为 url，并且将文件发送到输出文件夹。</li><li>url-loader：和 file-loader 类似，但是能在文件指定大小下以 base64 的方式把文件内容注入到代码中去</li><li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li><li>image-loader：加载并且压缩图片文件</li><li>babel-loader：把 ES6 转换成 ES5</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul></div><ol start="4"><li><strong>有哪些常见的Plugin？</strong></li></ol><div class="hint-container tip"><p class="hint-container-title">答案示例</p><ul><li>define-plugin：定义环境变量</li><li>commons-chunk-plugin：提取公共代码</li><li>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li></ul></div><ol start="5"><li><strong>Loader和Plugin的不同？</strong></li></ol><div class="hint-container tip"><p class="hint-container-title">答案示例</p><p><code>不同的作用</code></p><ul><li>Loader直译为&quot;加载器&quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</li><li>Plugin直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><p><code>不同的用法</code></p><ul><li>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li><li>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</li></ul></div>',10);function s(d,u){return i(),t("div",null,[n,a(" more "),p])}const b=e(r,[["render",s],["__file","interview.html.vue"]]);export{b as default};
